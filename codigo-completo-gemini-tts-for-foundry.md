<!-- markdown que recopila todo el codigo del proyecto para análisis -->

# Código Completo del Módulo: Gemini TTS for Foundry

Este documento contiene una copia completa de todos los archivos de código fuente del módulo "Gemini TTS for Foundry" para facilitar su revisión y análisis.

---

## `module.json`

```json
{
  "id": "gemini-tts-for-foundry",
  "title": "Gemini TTS for Foundry",
  "description": "Allows users to generate text-to-speech audio using the Google Gemini API and broadcast it to all players, providing a crucial communication tool for players without a microphone.",
  "version": "1.3.0",
  "authors": [
    {
      "name": "Gemini Assistant"
    }
  ],
  "compatibility": {
    "minimum": "11",
    "verified": "12"
  },
  "esmodules": [
    "main.js"
  ],
  "styles": [
    "styles/style.css"
  ],
  "languages": [
    {
      "lang": "en",
      "name": "English",
      "path": "lang/en.json"
    }
  ],
  "templates": [
    "templates/actor-voice-setting.txt",
    "templates/tts-panel.txt"
  ],
  "socket": true
}
```

---

## `lang/en.json`

```json
{
  "GEMINI-TTS": {
    "ButtonTitle": "Gemini Text-to-Speech",
    "DialogTitle": "Generate Speech with Gemini",
    "PanelTitle": "TTS Control Panel",
    "TextPlaceholder": "Enter text to speak...",
    "VoiceLabel": "Select Voice",
    "SpeakButton": "Speak",
    "CancelButton": "Cancel",
    "StopAllButton": "Stop All Audio",
    "VolumeLabel": "Global Volume",
    "QueueTitle": "Audio Queue",
    "ActorVoiceLabel": "Gemini TTS Voice",
    "Notifications": {
      "ApiKeyMissing": "Gemini API Key is not configured. Please set it in the module settings.",
      "ApiError": "Gemini API Error: {error}",
      "ApiErrorQuota": "API quota limit exceeded. Please try again later.",
      "ApiErrorNetwork": "Connection error. Please check your internet connection.",
      "ApiErrorInvalidKey": "Invalid or missing API key. The GM must configure it.",
      "EmptyText": "Cannot speak an empty text.",
      "Generating": "Generating audio...",
      "RateLimit": "You have reached the TTS request limit. Please wait a moment.",
      "ValidationErrorTooLong": "Text is too long (max 5000 characters)."
    },
    "Voices": {
      "Zephyr": "Zephyr (Female)",
      "Charon": "Charon (Deep Male)",
      "Kore": "Kore (Female)",
      "Puck": "Puck (Youthful Male)",
      "Fenrir": "Fenrir (Mature Male)"
    },
    "Settings": {
      "ApiKey": {
        "Name": "Google Gemini API Key",
        "Hint": "Enter your API Key for the Google Gemini Generative Language API."
      },
      "EnableActorVoices": {
        "Name": "Enable Actor-specific Voices",
        "Hint": "If enabled, allows assigning a default TTS voice to each character in their sheet."
      },
      "CacheEnabled": {
        "Name": "Enable Audio Caching",
        "Hint": "If enabled, frequently used phrases will be cached to reduce API calls and improve speed."
      },
      "GlobalVolume": {
        "Name": "Global TTS Volume",
        "Hint": "Controls the master volume for all audio generated by Gemini TTS."
      }
    }
  }
}
```

---

## `styles/style.css`

```css
.chat-control-icon.gemini-tts-button {
  margin-left: 5px;
}

/* New TTS Control Panel Styles */
.gemini-tts-panel {
    min-width: 350px;
    min-height: 400px;
}

.gemini-tts-panel .window-content {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.gemini-tts-panel .form-group {
    display: flex;
    flex-direction: column;
}

.gemini-tts-panel label {
    font-weight: bold;
    margin-bottom: 5px;
}

.gemini-tts-panel textarea {
    width: 100%;
    height: 100px;
    resize: vertical;
    box-sizing: border-box;
}

.gemini-tts-panel select, .gemini-tts-panel input[type="range"] {
    width: 100%;
    box-sizing: border-box;
}

.gemini-tts-panel .panel-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.gemini-tts-panel .panel-controls button {
    flex-grow: 1;
}

.gemini-tts-panel .tts-queue {
    border-top: 1px solid #CCC;
    padding-top: 10px;
    margin-top: 10px;
    flex-grow: 1;
}

.gemini-tts-panel .tts-queue h4 {
    margin-top: 0;
    margin-bottom: 10px;
    border-bottom: 1px solid #DDD;
    padding-bottom: 5px;
}

.gemini-tts-panel .tts-queue-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
    max-height: 150px;
    overflow-y: auto;
}

.gemini-tts-panel .tts-queue-list li {
    background: rgba(0, 0, 0, 0.05);
    padding: 5px 8px;
    border-radius: 3px;
    margin-bottom: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9em;
}


/* Styles for Actor Sheet Integration */
.gemini-tts-actor-voice {
    padding: 10px;
    border-top: 1px solid #CCC;
    margin-top: 10px;
}

.gemini-tts-actor-voice .form-group {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
}

.gemini-tts-actor-voice label {
    font-weight: bold;
    margin-right: 10px;
    flex-shrink: 0;
}

.gemini-tts-actor-voice select {
    flex-grow: 1;
}
```

---

## `main.js`

```javascript
const MODULE_ID = 'gemini-tts-for-foundry';
const SOCKET_NAME = `module.${MODULE_ID}`;

const DEBUG = false; // Set to true for verbose debugging in the console

let ttsPanelInstance = null;
let activeSounds = new Set();

function debugLog(...args) {
    if (DEBUG) {
        console.log(`[${MODULE_ID}] |`, ...args);
    }
}

// --- System Classes (Validation, Rate Limiting, Cache, Queue) ---

class TTSValidator {
  static validateTTSRequest(text, voiceName) {
    const errors = [];
    
    if (!text || text.trim().length === 0) {
      errors.push(game.i18n.localize('GEMINI-TTS.Notifications.EmptyText'));
    }
    
    if (text.length > 5000) {
      errors.push(game.i18n.localize('GEMINI-TTS.Notifications.ValidationErrorTooLong'));
    }
    
    const validVoices = ['Zephyr', 'Charon', 'Kore', 'Puck', 'Fenrir'];
    if (!validVoices.includes(voiceName)) {
      errors.push("Invalid voice selected.");
    }
    
    const sanitizedText = text.trim().substring(0, 5000);
    
    return {
      isValid: errors.length === 0,
      errors,
      sanitizedText
    };
  }
}

class TTSRateLimiter {
  constructor() {
    this.requests = new Map();
    this.maxRequestsPerMinute = 30;
  }
  
  canMakeRequest(userId) {
    const now = Date.now();
    const userRequests = this.requests.get(userId) || [];
    
    const recentRequests = userRequests.filter(time => now - time < 60000);
    
    if (recentRequests.length >= this.maxRequestsPerMinute) {
      return false;
    }
    
    recentRequests.push(now);
    this.requests.set(userId, recentRequests);
    return true;
  }
}

class TTSCache {
  constructor() {
    this.cache = new Map();
    this.maxSize = 100;
  }

  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  getKey(text, voice) {
    const hash = this.simpleHash(text);
    return `${voice}-${hash}-${text.length}`;
  }

  get(text, voice) {
    return this.cache.get(this.getKey(text, voice));
  }

  set(text, voice, audioB64) {
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(this.getKey(text, voice), audioB64);
  }
}

class TTSQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  add(request) {
    this.queue.push(request);
    if (ttsPanelInstance) ttsPanelInstance.render(false);
    this.process();
  }

  async process() {
    if (this.processing || this.queue.length === 0) return;
    if (!game.user.isGM) return; // Double security check

    this.processing = true;
    const { text, voiceName, requestingUserId } = this.queue.shift();
    debugLog('Processing TTS request:', `"${text.substring(0, 50)}..."`, 'for user', requestingUserId);
    if (ttsPanelInstance) ttsPanelInstance.render(false);

    try {
      const apiKey = game.settings.get(MODULE_ID, 'apiKey');
      if (!apiKey) throw new Error(game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorInvalidKey'));
      
      let audioB64;
      const useCache = game.settings.get(MODULE_ID, 'cacheEnabled');

      if (useCache) {
          audioB64 = ttsCache.get(text, voiceName);
          if (audioB64) debugLog('Cache hit for request.');
      }

      if (!audioB64) {
        debugLog('Cache miss. Calling Gemini API.');
        ui.notifications.info(game.i18n.localize('GEMINI-TTS.Notifications.Generating'));
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: text }] }],
                config: {
                    responseModalities: ['AUDIO'],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } } }
                }
            })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error.message || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        audioB64 = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

        if (useCache && audioB64) {
            ttsCache.set(text, voiceName, audioB64);
            debugLog('Saved new audio to cache.');
        }
      }

      if (audioB64) {
        game.socket.emit(SOCKET_NAME, { type: 'play', audioB64 });
      } else {
        throw new Error("No audio data received from API.");
      }

    } catch (err) {
      console.error(`${MODULE_ID} | API Error:`, err);
      let userMessage;
      const errorStr = err.message.toLowerCase();
      
      if (errorStr.includes('quota') || errorStr.includes('429')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorQuota');
      } else if (errorStr.includes('network') || errorStr.includes('fetch')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorNetwork');
      } else if (errorStr.includes('api key') || errorStr.includes('403')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorInvalidKey');
      } else {
        userMessage = err.message;
      }

      if (game.user.isGM) {
        ui.notifications.error(game.i18n.format('GEMINI-TTS.Notifications.ApiError', { error: userMessage }));
      }
    } finally {
      this.processing = false;
      setTimeout(() => this.process(), 100); 
    }
  }
}

const ttsCache = new TTSCache();
const ttsQueue = game.user.isGM ? new TTSQueue() : null;
const rateLimiter = game.user.isGM ? new TTSRateLimiter() : null;

// --- Audio Playback ---

function decodeBase64(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

function createWavHeader(pcmDataLength) {
  const sampleRate = 24000;
  const numChannels = 1;
  const bitsPerSample = 16;
  const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
  const blockAlign = numChannels * (bitsPerSample / 8);

  const buffer = new ArrayBuffer(44);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + pcmDataLength, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);
  writeString(view, 36, 'data');
  view.setUint32(40, pcmDataLength, true);

  return new Uint8Array(buffer);
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

async function playAudioFromBase64(base64Data) {
    let url;
    try {
        const pcmData = decodeBase64(base64Data);
        const wavHeader = createWavHeader(pcmData.length);
        const wavData = new Uint8Array(wavHeader.length + pcmData.length);
        
        wavData.set(wavHeader, 0);
        wavData.set(pcmData, wavHeader.length);

        const blob = new Blob([wavData], { type: 'audio/wav' });
        url = URL.createObjectURL(blob);
        
        const volume = game.settings.get(MODULE_ID, 'globalVolume');
        const sound = await AudioHelper.play({ src: url, volume: volume, autoplay: true, loop: false }, false);
        
        if (sound) {
            activeSounds.add(sound);
            const onEnd = () => {
                activeSounds.delete(sound);
                URL.revokeObjectURL(url);
                debugLog('Audio ended and URL revoked.');
            };
            sound.on('end', onEnd);
            sound.on('error', onEnd);
        } else {
            URL.revokeObjectURL(url);
            debugLog('Sound object creation failed, URL revoked.');
        }
    } catch (error) {
        if (url) URL.revokeObjectURL(url);
        console.error(`${MODULE_ID} | Audio playback error:`, error);
    }
}

function stopAllSounds() {
    activeSounds.forEach(sound => {
        sound.stop();
    });
    activeSounds.clear();
    debugLog('All sounds stopped via stopAllSounds()');
}


// --- UI & Control Panel ---

class TTSControlPanel extends Application {
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            id: 'gemini-tts-panel',
            classes: ['gemini-tts-panel'],
            template: `modules/${MODULE_ID}/templates/tts-panel.txt`,
            title: game.i18n.localize('GEMINI-TTS.PanelTitle'),
            width: 400,
            height: 'auto',
            resizable: true,
        });
    }

    getData() {
        const voices = [
            { key: 'Zephyr', label: game.i18n.localize('GEMINI-TTS.Voices.Zephyr') },
            { key: 'Charon', label: game.i18n.localize('GEMINI-TTS.Voices.Charon') },
            { key: 'Kore', label: game.i18n.localize('GEMINI-TTS.Voices.Kore') },
            { key: 'Puck', label: game.i18n.localize('GEMINI-TTS.Voices.Puck') },
            { key: 'Fenrir', label: game.i18n.localize('GEMINI-TTS.Voices.Fenrir') },
        ];
        
        const preferredVoice = game.settings.get(MODULE_ID, 'enableActorVoices') 
            ? game.user.character?.getFlag(MODULE_ID, 'voice') 
            : null;
        
        const queue = game.user.isGM && ttsQueue ? ttsQueue.queue : [];
            
        return {
            voices: voices.map(v => ({...v, selected: v.key === preferredVoice })),
            queue: queue,
            volume: game.settings.get(MODULE_ID, 'globalVolume') * 100
        };
    }

    activateListeners(html) {
        super.activateListeners(html);
        const textInput = html.find('[name="tts-text"]');
        
        html.find('.tts-speak-btn').on('click', () => {
            const text = textInput.val();
            const voiceName = html.find('[name="tts-voice"]').val();
            
            const validation = TTSValidator.validateTTSRequest(text, voiceName);
            if (!validation.isValid) {
                validation.errors.forEach(error => ui.notifications.warn(error));
                return;
            }

            game.socket.emit(SOCKET_NAME, { 
                type: 'ttsRequest', 
                text: validation.sanitizedText, 
                voiceName,
                userId: game.user.id 
            });

            textInput.val('');
        });
        
        html.find('.tts-stop-all-btn').on('click', () => {
            game.socket.emit(SOCKET_NAME, { type: 'stop' });
        });

        html.find('#tts-volume-slider').on('input', (event) => {
            const volume = $(event.currentTarget).val() / 100;
            game.settings.set(MODULE_ID, 'globalVolume', volume);
            html.find('#tts-volume-value').text(`${Math.round(volume * 100)}%`);
        });
    }

    async close(options) {
        ttsPanelInstance = null;
        return super.close(options);
    }
}


// --- Foundry VTT Hooks ---

Hooks.once('init', () => {
  game.settings.register(MODULE_ID, 'apiKey', {
    name: game.i18n.localize('GEMINI-TTS.Settings.ApiKey.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.ApiKey.Hint'),
    scope: 'world', config: true, type: String, default: '',
  });

  game.settings.register(MODULE_ID, 'enableActorVoices', {
    name: game.i18n.localize('GEMINI-TTS.Settings.EnableActorVoices.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.EnableActorVoices.Hint'),
    scope: 'world', config: true, type: Boolean, default: true,
  });

  game.settings.register(MODULE_ID, 'cacheEnabled', {
    name: game.i18n.localize('GEMINI-TTS.Settings.CacheEnabled.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.CacheEnabled.Hint'),
    scope: 'world', config: true, type: Boolean, default: true,
  });
  
  game.settings.register(MODULE_ID, 'globalVolume', {
    name: game.i18n.localize('GEMINI-TTS.Settings.GlobalVolume.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.GlobalVolume.Hint'),
    scope: 'client', config: true, type: Number, range: { min: 0, max: 1, step: 0.01 }, default: 0.8,
  });

  loadTemplates([
    `modules/${MODULE_ID}/templates/actor-voice-setting.txt`,
    `modules/${MODULE_ID}/templates/tts-panel.txt`
  ]);
});

Hooks.on('renderChatLog', (app, html) => {
  const button = $(`<a class="chat-control-icon gemini-tts-button" title="${game.i18n.localize('GEMINI-TTS.ButtonTitle')}"><i class="fas fa-microphone-alt"></i></a>`);
  button.on('click', () => {
    if (ttsPanelInstance) {
        ttsPanelInstance.render(true);
        ttsPanelInstance.bringToTop();
    } else {
        ttsPanelInstance = new TTSControlPanel().render(true);
    }
  });
  html.find('.chat-controls').prepend(button);
});

Hooks.on('renderActorSheet', async (app, html, data) => {
    if (!game.settings.get(MODULE_ID, 'enableActorVoices')) return;
    const actor = app.actor;
    if (!actor || (!actor.isOwner && !game.user.isGM)) return;
    
    const voices = [
      { key: 'Zephyr', label: game.i18n.localize('GEMINI-TTS.Voices.Zephyr') },
      { key: 'Charon', label: game.i18n.localize('GEMINI-TTS.Voices.Charon') },
      { key: 'Kore', label: game.i18n.localize('GEMINI-TTS.Voices.Kore') },
      { key: 'Puck', label: game.i18n.localize('GEMINI-TTS.Voices.Puck') },
      { key: 'Fenrir', label: game.i18n.localize('GEMINI-TTS.Voices.Fenrir') },
    ];
    
    const preferredVoice = actor.getFlag(MODULE_ID, 'voice') || voices[0].key;

    const templateData = {
        moduleId: MODULE_ID,
        voices: voices.map(v => ({...v, selected: v.key === preferredVoice })),
    };
    
    const renderedTemplate = await renderTemplate(`modules/${MODULE_ID}/templates/actor-voice-setting.txt`, templateData);

    const biographyTab = html.find('.tab[data-tab="biography"]');
    if (biographyTab.length > 0) {
        biographyTab.append(renderedTemplate);
    } else {
        const header = html.find('.window-header, .sheet-header');
        header.after(renderedTemplate);
    }
    
    html.find(`select[name="flags.${MODULE_ID}.voice"]`).on('change', async (event) => {
        await actor.setFlag(MODULE_ID, 'voice', $(event.currentTarget).val());
        ui.notifications.info(`${actor.name}'s voice has been set.`);
    });
});


Hooks.once('ready', () => {
    game.socket.on(SOCKET_NAME, (data) => {
        if (data.type === 'ttsRequest' && game.user.isGM) {
            if (!rateLimiter.canMakeRequest(data.userId)) {
                debugLog(`Rate limit exceeded for user ${data.userId}`);
                game.socket.emit(SOCKET_NAME, { 
                    type: 'notify', 
                    message: game.i18n.localize('GEMINI-TTS.Notifications.RateLimit'),
                    level: 'warning'
                }, { recipients: [data.userId] }); // Foundry handles targeting
                return;
            }
            ttsQueue.add({ text: data.text, voiceName: data.voiceName, requestingUserId: data.userId });
            return;
        }

        switch(data.type) {
            case 'play':
                if (data.audioB64) playAudioFromBase64(data.audioB64);
                break;
            case 'stop':
                stopAllSounds();
                break;
            case 'notify':
                // This client has received a targeted notification from the GM
                ui.notifications[data.level || 'info'](data.message);
                break;
        }
    });
});
```

---

## `README.md`

```markdown
# Gemini TTS for Foundry

Un módulo para Foundry VTT que permite a los usuarios generar audio de texto a voz (Text-to-Speech) de alta calidad utilizando la API de Google Gemini. El audio generado se transmite instantáneamente a todos los jugadores conectados, proporcionando una herramienta de comunicación y accesibilidad crucial para jugadores sin micrófono o para mejorar la inmersión en la partida.

## Características

- **Audio de Alta Calidad:** Utiliza los modelos de voz de Google Gemini para una narración clara y natural.
- **Transmisión en Tiempo Real:** El audio se comparte con todos los jugadores en la sesión a través de sockets para una experiencia sincronizada.
- **Selección de Voz:** Permite elegir entre varias voces de Gemini para adaptarse a diferentes personajes o narradores.
- **Integración Sencilla:** Añade un botón de fácil acceso directamente en la ventana de chat de Foundry.
- **Configuración Fácil:** El Game Master (GM) puede configurar la clave de la API necesaria a través del menú de ajustes del módulo.
- **Voces por Personaje:** Asigna voces por defecto a personajes específicos desde su ficha de actor.
- **Sistema de Caché y Cola:** Optimiza las llamadas a la API y gestiona múltiples solicitudes de audio de forma fluida.

## Instalación

1.  En el menú principal de Foundry VTT, ve a la pestaña **"Setup"**.
2.  Haz clic en el botón **"Add-on Modules"**.
3.  Haz clic en **"Install Module"** en la parte inferior.
4.  En el campo "Manifest URL", copia y pega la siguiente URL:
    ```
    https://github.com/PachonX/gemini-tts-for-foundry/releases/latest/download/module.json
    ```
5.  Haz clic en **"Install"**.

Una vez instalado, no olvides activar el módulo dentro de tu mundo de juego.

## Configuración (Requerido para el Game Master)

Para que el módulo funcione, el Game Master debe configurar una clave de API de Google Gemini.

1.  Una vez dentro de tu mundo en Foundry, ve al menú de la derecha y haz clic en la pestaña **"Game Settings"** (el icono del engranaje).
2.  Haz clic en el botón **"Configure Settings"**.
3.  Selecciona la pestaña **"Module Settings"**.
4.  Busca la sección correspondiente a **"Gemini TTS for Foundry"**.
5.  En el campo llamado **"Google Gemini API Key"**, pega tu clave de API. Puedes obtener una desde [Google AI Studio](https://aistudio.google.com/app/apikey).
6.  Haz clic en **"Save Changes"** en la parte inferior.

¡El módulo ya está listo para ser utilizado por todos los jugadores!

## ¿Cómo se Usa? (Para Jugadores)

Cualquier jugador en la partida puede generar audio:

1.  En la ventana de chat, haz clic en el nuevo **ícono de micrófono** que aparece en la barra de controles.
2.  Se abrirá una ventana emergente titulada "Generate Speech with Gemini".
3.  Escribe el texto que deseas que se hable en el cuadro de texto.
4.  Selecciona una de las voces disponibles en el menú desplegable. Si tu personaje tiene una voz asignada, se seleccionará automáticamente.
5.  Haz clic en el botón **"Speak"**.

El audio se generará y se reproducirá automáticamente para todos los jugadores en la partida.

---

### **Nota para Desarrolladores**

Este proyecto utiliza un workaround para la compatibilidad con el entorno de desarrollo. Los archivos de plantilla de Handlebars (`.hbs`) se guardan en el repositorio como archivos `.txt`.

**Acción Requerida antes de Publicar:** Antes de crear una nueva release o empaquetar el módulo, debes renombrar los siguientes archivos en la carpeta `templates/`:
- `actor-voice-setting.txt` -> `actor-voice-setting.hbs`
- `tts-panel.txt` -> `tts-panel.hbs`
---

# CHANGELOG - Gemini TTS for Foundry

## [v1.3.0] - 2024-XX-XX

### 🚀 **Nuevas Características**

#### **Seguridad y Arquitectura**
- 🔒 **Arquitectura segura GM-centralizada**: Solo el Game Master realiza llamadas a la API
- 🛡️ **Protección de credenciales**: La API Key nunca se expone a los jugadores
- ⚡ **Sistema de rate limiting**: Límite de 30 solicitudes por minuto por usuario
- ✅ **Validación robusta**: Sanitización de texto y límites de caracteres (5000 max)

#### **Interfaz de Usuario Mejorada**
- 🎛️ **Panel de control flotante**: Reemplaza el diálogo modal por ventana persistente
- 📋 **Cola visual de audio**: Los usuarios ven el estado de sus solicitudes pendientes
- 🔊 **Control de volumen global**: Ajuste maestro para todos los audios TTS
- ⏹️ **Botón "Stop All Audio"**: Detiene inmediatamente toda reproducción
- 🎭 **Integración en fichas de actor**: Configuración de voces por personaje

#### **Rendimiento y Optimización**
- 💾 **Sistema de cache inteligente**: Almacena audios frecuentes con hash eficiente
- 🔄 **Procesamiento en cola**: Maneja múltiples solicitudes simultáneas
- 🧹 **Gestión de memoria**: Liberación automática de URLs de audio
- 🐛 **Sistema de debug**: Logging opcional para troubleshooting

### 🎯 **Mejoras de Experiencia**

#### **Para el Game Master**
- 🤖 **Proceso completamente automático**: CERO popups de confirmación
- ⏱️ **Sin interrupciones**: El GM puede seguir jugando sin molestias
- 📊 **Control total**: Monitoreo de uso y prevención de abusos
- 💰 **Control de costos**: Una sola llamada API por solicitud

#### **Para los Jugadores**
- 🎨 **Interfaz intuitiva**: Panel de control fácil de usar
- ⏳ **Feedback visual**: Ver la cola de audios pendientes
- 🎵 **Experiencia consistente**: Audio sincronizado para todos los jugadores
- 🔧 **Personalización**: Voces específicas por personaje

### 🔧 **Cambios Técnicos**

#### **Arquitectura**
- 🔄 **Sistema de sockets**: Comunicación bidireccional segura
- 🏗️ **Clases modulares**: Validator, RateLimiter, Cache, Queue
- 🌐 **Manejo de errores**: Clasificación inteligente de errores de API
- 📡 **Transmisión eficiente**: Audio enviado una vez, reproducido en todos los clientes

#### **Configuración**
- ⚙️ **Settings expandidos**: 
  - API Key (solo GM)
  - Habilitar voces por actor
  - Cache habilitado/deshabilitado
  - Volumen global TTS

### 🐛 **Correcciones de Errores**

- **Gestión de memoria**: URLs de Blob liberadas correctamente
- **Manejo de errores**: Notificaciones específicas por tipo de error
- **Validación de entrada**: Prevención de textos vacíos o demasiado largos
- **Sincronización**: Reproducción consistente en todos los clientes

### 📈 **Compatibilidad**

- ✅ **Foundry VTT**: Versiones 11-12 verificadas
- ✅ **Sistemas**: Compatible con todos los sistemas de juego
- ✅ **Módulos**: No presenta conflictos conocidos

---

## [v1.0.0] - 2024-XX-XX
### **Lanzamiento Inicial**
- Funcionalidad básica de Text-to-Speech con Gemini API
- Diálogo simple para generar audio
- Transmisión básica a todos los jugadores

---

**¿Listo para actualizar?** Simplemente instala la nueva versión y configura tu API Key en los ajustes del módulo. ¡El GM no necesita hacer nada más - el sistema funciona automáticamente! 🎉

*Nota: Los usuarios de versiones anteriores pueden actualizar sin problemas - todas las configuraciones se mantienen.*
```

---

## `roadmap.md`

```markdown
# Roadmap de "Gemini TTS for Foundry"

Este documento describe las futuras mejoras y características planificadas para el módulo, basadas en las excelentes sugerencias de la comunidad.

## 🚀 Próximas Funcionalidades

### 1. Sistema de Macros y Automatización
- [ ] **Crear una API externa**: Exponer funciones como `game.modules.get('gemini-tts-for-foundry').api.speakAsCharacter(actorId, text)` para permitir que otros módulos y macros activen el TTS de forma programática.
- [ ] **Documentar la API**: Proporcionar ejemplos claros de cómo usar la API para automatizar la narración o los diálogos de los personajes.

### 2. Soporte para Múltiples Proveedores de TTS
- [ ] **Abstraer el servicio de TTS**: Refactorizar el código para desacoplar la lógica de la API de Gemini y permitir la integración de otros proveedores (como ElevenLabs, OpenAI TTS, etc.).
- [ ] **Añadir configuración de proveedor**: Incluir una opción en los ajustes del módulo para que el GM elija qué servicio de TTS utilizar.

### 3. Interfaz de Usuario Mejorada (Panel de Control)
- [x] **Panel de control flotante**: Reemplazar el diálogo modal con una ventana `Application` flotante que puede permanecer abierta.
- [x] **Controles avanzados**: Añadir controles de volumen global, un botón de "parar todo el audio", y una vista de la cola de TTS actual.

### 4. Sistema de Efectos de Sonido y Modulación
- [ ] **Integración con la Web Audio API**: Implementar una clase `AudioEffects` para procesar el audio antes de reproducirlo.
- [ ] **Efectos configurables**: Añadir opciones en el diálogo de TTS para aplicar efectos básicos como cambio de tono (pitch shift) o reverberación, útiles para voces de monstruos o ambientes específicos.

### 5. Integración con el Sistema de Escenas
- [ ] **Audio ambiental por escena**: Permitir al GM configurar un texto y una voz para que se reproduzca en bucle como ambiente sonoro cuando una escena se activa.
- [ ] **Triggers de audio**: Explorar la posibilidad de vincular audios de TTS a zonas específicas del mapa (usando módulos como Multilevel Tokens o Trigger Happy).

### 6. Sistema de Plantillas de Diálogo
- [ ] **Interfaz para plantillas**: Crear una UI donde los GMs puedan definir y guardar plantillas de frases comunes (ej. ataques, hechizos, interacciones sociales).
- [ ] **Acceso rápido**: Integrar un selector de plantillas en el diálogo de TTS para una selección rápida.

### 7. Sistema de Filtros de Contenido
- [ ] **Añadir ajuste de filtro**: Implementar la configuración `contentFilterLevel` (Ninguno, Estándar, Estricto) sugerida.
- [ ] **Lógica de filtrado**: Crear una función `ContentFilter` que procese el texto antes de enviarlo a la API para reemplazar palabras o frases no deseadas.

### 8. Métricas y Analytics (Opcional)
- [ ] **Mecanismo de opt-in**: Añadir una opción de configuración para que los GMs puedan habilitar el envío anónimo de métricas de uso.
- [ ] **Recopilación de datos básicos**: Registrar eventos como `generacion_exitosa`, `error_api`, `cache_hit` para ayudar a identificar problemas y priorizar mejoras.
```

---

## `templates/actor-voice-setting.txt`

```html
<div class="form-group gemini-tts-actor-voice">
    <label for="gemini-tts-voice-select">{{localize "GEMINI-TTS.ActorVoiceLabel"}}</label>
    <select name="flags.{{moduleId}}.voice" id="gemini-tts-voice-select">
        {{#each voices}}
        <option value="{{this.key}}" {{#if this.selected}}selected{{/if}}>{{this.label}}</option>
        {{/each}}
    </select>
</div>
```

---

## `templates/tts-panel.txt`

```html
<div class="form-group">
    <label for="tts-text">{{localize "GEMINI-TTS.TextPlaceholder"}}</label>
    <textarea name="tts-text" id="tts-text" rows="4" placeholder="{{localize 'GEMINI-TTS.TextPlaceholder'}}"></textarea>
</div>

<div class="form-group">
    <label for="tts-voice">{{localize "GEMINI-TTS.VoiceLabel"}}</label>
    <select name="tts-voice" id="tts-voice">
        {{#each voices}}
        <option value="{{this.key}}" {{#if this.selected}}selected{{/if}}>{{this.label}}</option>
        {{/each}}
    </select>
</div>

<div class="form-group">
    <label for="tts-volume-slider">{{localize "GEMINI-TTS.VolumeLabel"}} <span id="tts-volume-value">{{volume}}%</span></label>
    <input type="range" id="tts-volume-slider" min="0" max="100" value="{{volume}}" class="slider">
</div>

<div class="panel-controls">
    <button class="tts-speak-btn"><i class="fas fa-microphone-alt"></i> {{localize "GEMINI-TTS.SpeakButton"}}</button>
    <button class="tts-stop-all-btn" style="background-color: #c9302c;"><i class="fas fa-stop-circle"></i> {{localize "GEMINI-TTS.StopAllButton"}}</button>
</div>

<div class="tts-queue">
    <h4><i class="fas fa-list-ol"></i> {{localize "GEMINI-TTS.QueueTitle"}}</h4>
    <ol class="tts-queue-list">
        {{#if queue.length}}
            {{#each queue}}
            <li title="{{this.text}}">{{this.text}}</li>
            {{/each}}
        {{else}}
            <li>&nbsp;</li>
        {{/if}}
    </ol>
</div>