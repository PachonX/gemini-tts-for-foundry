<!-- markdown que recopila todo el codigo del proyecto para an谩lisis -->

# C贸digo Completo del M贸dulo: Gemini TTS for Foundry

Este documento contiene una copia completa de todos los archivos de c贸digo fuente del m贸dulo "Gemini TTS for Foundry" para facilitar su revisi贸n y an谩lisis.

---

## `module.json`

```json
{
  "id": "gemini-tts-for-foundry",
  "title": "Gemini TTS for Foundry",
  "description": "Allows users to generate text-to-speech audio using the Google Gemini API and broadcast it to all players, providing a crucial communication tool for players without a microphone.",
  "version": "1.3.0",
  "authors": [
    {
      "name": "Gemini Assistant"
    }
  ],
  "compatibility": {
    "minimum": "11",
    "verified": "12"
  },
  "esmodules": [
    "main.js"
  ],
  "styles": [
    "styles/style.css"
  ],
  "languages": [
    {
      "lang": "en",
      "name": "English",
      "path": "lang/en.json"
    }
  ],
  "templates": [
    "templates/actor-voice-setting.txt",
    "templates/tts-panel.txt"
  ],
  "socket": true
}
```

---

## `lang/en.json`

```json
{
  "GEMINI-TTS": {
    "ButtonTitle": "Gemini Text-to-Speech",
    "DialogTitle": "Generate Speech with Gemini",
    "PanelTitle": "TTS Control Panel",
    "TextPlaceholder": "Enter text to speak...",
    "VoiceLabel": "Select Voice",
    "SpeakButton": "Speak",
    "CancelButton": "Cancel",
    "StopAllButton": "Stop All Audio",
    "VolumeLabel": "Global Volume",
    "QueueTitle": "Audio Queue",
    "ActorVoiceLabel": "Gemini TTS Voice",
    "Notifications": {
      "ApiKeyMissing": "Gemini API Key is not configured. Please set it in the module settings.",
      "ApiError": "Gemini API Error: {error}",
      "ApiErrorQuota": "API quota limit exceeded. Please try again later.",
      "ApiErrorNetwork": "Connection error. Please check your internet connection.",
      "ApiErrorInvalidKey": "Invalid or missing API key. The GM must configure it.",
      "EmptyText": "Cannot speak an empty text.",
      "Generating": "Generating audio...",
      "RateLimit": "You have reached the TTS request limit. Please wait a moment.",
      "ValidationErrorTooLong": "Text is too long (max 5000 characters)."
    },
    "Voices": {
      "Zephyr": "Zephyr (Female)",
      "Charon": "Charon (Deep Male)",
      "Kore": "Kore (Female)",
      "Puck": "Puck (Youthful Male)",
      "Fenrir": "Fenrir (Mature Male)"
    },
    "Settings": {
      "ApiKey": {
        "Name": "Google Gemini API Key",
        "Hint": "Enter your API Key for the Google Gemini Generative Language API."
      },
      "EnableActorVoices": {
        "Name": "Enable Actor-specific Voices",
        "Hint": "If enabled, allows assigning a default TTS voice to each character in their sheet."
      },
      "CacheEnabled": {
        "Name": "Enable Audio Caching",
        "Hint": "If enabled, frequently used phrases will be cached to reduce API calls and improve speed."
      },
      "GlobalVolume": {
        "Name": "Global TTS Volume",
        "Hint": "Controls the master volume for all audio generated by Gemini TTS."
      }
    }
  }
}
```

---

## `styles/style.css`

```css
.chat-control-icon.gemini-tts-button {
  margin-left: 5px;
}

/* New TTS Control Panel Styles */
.gemini-tts-panel {
    min-width: 350px;
    min-height: 400px;
}

.gemini-tts-panel .window-content {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.gemini-tts-panel .form-group {
    display: flex;
    flex-direction: column;
}

.gemini-tts-panel label {
    font-weight: bold;
    margin-bottom: 5px;
}

.gemini-tts-panel textarea {
    width: 100%;
    height: 100px;
    resize: vertical;
    box-sizing: border-box;
}

.gemini-tts-panel select, .gemini-tts-panel input[type="range"] {
    width: 100%;
    box-sizing: border-box;
}

.gemini-tts-panel .panel-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.gemini-tts-panel .panel-controls button {
    flex-grow: 1;
}

.gemini-tts-panel .tts-queue {
    border-top: 1px solid #CCC;
    padding-top: 10px;
    margin-top: 10px;
    flex-grow: 1;
}

.gemini-tts-panel .tts-queue h4 {
    margin-top: 0;
    margin-bottom: 10px;
    border-bottom: 1px solid #DDD;
    padding-bottom: 5px;
}

.gemini-tts-panel .tts-queue-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
    max-height: 150px;
    overflow-y: auto;
}

.gemini-tts-panel .tts-queue-list li {
    background: rgba(0, 0, 0, 0.05);
    padding: 5px 8px;
    border-radius: 3px;
    margin-bottom: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9em;
}


/* Styles for Actor Sheet Integration */
.gemini-tts-actor-voice {
    padding: 10px;
    border-top: 1px solid #CCC;
    margin-top: 10px;
}

.gemini-tts-actor-voice .form-group {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
}

.gemini-tts-actor-voice label {
    font-weight: bold;
    margin-right: 10px;
    flex-shrink: 0;
}

.gemini-tts-actor-voice select {
    flex-grow: 1;
}
```

---

## `main.js`

```javascript
const MODULE_ID = 'gemini-tts-for-foundry';
const SOCKET_NAME = `module.${MODULE_ID}`;

const DEBUG = false; // Set to true for verbose debugging in the console

let ttsPanelInstance = null;
let activeSounds = new Set();

function debugLog(...args) {
    if (DEBUG) {
        console.log(`[${MODULE_ID}] |`, ...args);
    }
}

// --- System Classes (Validation, Rate Limiting, Cache, Queue) ---

class TTSValidator {
  static validateTTSRequest(text, voiceName) {
    const errors = [];
    
    if (!text || text.trim().length === 0) {
      errors.push(game.i18n.localize('GEMINI-TTS.Notifications.EmptyText'));
    }
    
    if (text.length > 5000) {
      errors.push(game.i18n.localize('GEMINI-TTS.Notifications.ValidationErrorTooLong'));
    }
    
    const validVoices = ['Zephyr', 'Charon', 'Kore', 'Puck', 'Fenrir'];
    if (!validVoices.includes(voiceName)) {
      errors.push("Invalid voice selected.");
    }
    
    const sanitizedText = text.trim().substring(0, 5000);
    
    return {
      isValid: errors.length === 0,
      errors,
      sanitizedText
    };
  }
}

class TTSRateLimiter {
  constructor() {
    this.requests = new Map();
    this.maxRequestsPerMinute = 30;
  }
  
  canMakeRequest(userId) {
    const now = Date.now();
    const userRequests = this.requests.get(userId) || [];
    
    const recentRequests = userRequests.filter(time => now - time < 60000);
    
    if (recentRequests.length >= this.maxRequestsPerMinute) {
      return false;
    }
    
    recentRequests.push(now);
    this.requests.set(userId, recentRequests);
    return true;
  }
}

class TTSCache {
  constructor() {
    this.cache = new Map();
    this.maxSize = 100;
  }

  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  getKey(text, voice) {
    const hash = this.simpleHash(text);
    return `${voice}-${hash}-${text.length}`;
  }

  get(text, voice) {
    return this.cache.get(this.getKey(text, voice));
  }

  set(text, voice, audioB64) {
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(this.getKey(text, voice), audioB64);
  }
}

class TTSQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  add(request) {
    this.queue.push(request);
    if (ttsPanelInstance) ttsPanelInstance.render(false);
    this.process();
  }

  async process() {
    if (this.processing || this.queue.length === 0) return;
    if (!game.user.isGM) return; // Double security check

    this.processing = true;
    const { text, voiceName, requestingUserId } = this.queue.shift();
    debugLog('Processing TTS request:', `"${text.substring(0, 50)}..."`, 'for user', requestingUserId);
    if (ttsPanelInstance) ttsPanelInstance.render(false);

    try {
      const apiKey = game.settings.get(MODULE_ID, 'apiKey');
      if (!apiKey) throw new Error(game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorInvalidKey'));
      
      let audioB64;
      const useCache = game.settings.get(MODULE_ID, 'cacheEnabled');

      if (useCache) {
          audioB64 = ttsCache.get(text, voiceName);
          if (audioB64) debugLog('Cache hit for request.');
      }

      if (!audioB64) {
        debugLog('Cache miss. Calling Gemini API.');
        ui.notifications.info(game.i18n.localize('GEMINI-TTS.Notifications.Generating'));
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: text }] }],
                config: {
                    responseModalities: ['AUDIO'],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } } }
                }
            })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error.message || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        audioB64 = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

        if (useCache && audioB64) {
            ttsCache.set(text, voiceName, audioB64);
            debugLog('Saved new audio to cache.');
        }
      }

      if (audioB64) {
        game.socket.emit(SOCKET_NAME, { type: 'play', audioB64 });
      } else {
        throw new Error("No audio data received from API.");
      }

    } catch (err) {
      console.error(`${MODULE_ID} | API Error:`, err);
      let userMessage;
      const errorStr = err.message.toLowerCase();
      
      if (errorStr.includes('quota') || errorStr.includes('429')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorQuota');
      } else if (errorStr.includes('network') || errorStr.includes('fetch')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorNetwork');
      } else if (errorStr.includes('api key') || errorStr.includes('403')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorInvalidKey');
      } else {
        userMessage = err.message;
      }

      if (game.user.isGM) {
        ui.notifications.error(game.i18n.format('GEMINI-TTS.Notifications.ApiError', { error: userMessage }));
      }
    } finally {
      this.processing = false;
      setTimeout(() => this.process(), 100); 
    }
  }
}

const ttsCache = new TTSCache();
const ttsQueue = game.user.isGM ? new TTSQueue() : null;
const rateLimiter = game.user.isGM ? new TTSRateLimiter() : null;

// --- Audio Playback ---

function decodeBase64(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

function createWavHeader(pcmDataLength) {
  const sampleRate = 24000;
  const numChannels = 1;
  const bitsPerSample = 16;
  const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
  const blockAlign = numChannels * (bitsPerSample / 8);

  const buffer = new ArrayBuffer(44);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + pcmDataLength, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);
  writeString(view, 36, 'data');
  view.setUint32(40, pcmDataLength, true);

  return new Uint8Array(buffer);
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

async function playAudioFromBase64(base64Data) {
    let url;
    try {
        const pcmData = decodeBase64(base64Data);
        const wavHeader = createWavHeader(pcmData.length);
        const wavData = new Uint8Array(wavHeader.length + pcmData.length);
        
        wavData.set(wavHeader, 0);
        wavData.set(pcmData, wavHeader.length);

        const blob = new Blob([wavData], { type: 'audio/wav' });
        url = URL.createObjectURL(blob);
        
        const volume = game.settings.get(MODULE_ID, 'globalVolume');
        const sound = await AudioHelper.play({ src: url, volume: volume, autoplay: true, loop: false }, false);
        
        if (sound) {
            activeSounds.add(sound);
            const onEnd = () => {
                activeSounds.delete(sound);
                URL.revokeObjectURL(url);
                debugLog('Audio ended and URL revoked.');
            };
            sound.on('end', onEnd);
            sound.on('error', onEnd);
        } else {
            URL.revokeObjectURL(url);
            debugLog('Sound object creation failed, URL revoked.');
        }
    } catch (error) {
        if (url) URL.revokeObjectURL(url);
        console.error(`${MODULE_ID} | Audio playback error:`, error);
    }
}

function stopAllSounds() {
    activeSounds.forEach(sound => {
        sound.stop();
    });
    activeSounds.clear();
    debugLog('All sounds stopped via stopAllSounds()');
}


// --- UI & Control Panel ---

class TTSControlPanel extends Application {
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            id: 'gemini-tts-panel',
            classes: ['gemini-tts-panel'],
            template: `modules/${MODULE_ID}/templates/tts-panel.txt`,
            title: game.i18n.localize('GEMINI-TTS.PanelTitle'),
            width: 400,
            height: 'auto',
            resizable: true,
        });
    }

    getData() {
        const voices = [
            { key: 'Zephyr', label: game.i18n.localize('GEMINI-TTS.Voices.Zephyr') },
            { key: 'Charon', label: game.i18n.localize('GEMINI-TTS.Voices.Charon') },
            { key: 'Kore', label: game.i18n.localize('GEMINI-TTS.Voices.Kore') },
            { key: 'Puck', label: game.i18n.localize('GEMINI-TTS.Voices.Puck') },
            { key: 'Fenrir', label: game.i18n.localize('GEMINI-TTS.Voices.Fenrir') },
        ];
        
        const preferredVoice = game.settings.get(MODULE_ID, 'enableActorVoices') 
            ? game.user.character?.getFlag(MODULE_ID, 'voice') 
            : null;
        
        const queue = game.user.isGM && ttsQueue ? ttsQueue.queue : [];
            
        return {
            voices: voices.map(v => ({...v, selected: v.key === preferredVoice })),
            queue: queue,
            volume: game.settings.get(MODULE_ID, 'globalVolume') * 100
        };
    }

    activateListeners(html) {
        super.activateListeners(html);
        const textInput = html.find('[name="tts-text"]');
        
        html.find('.tts-speak-btn').on('click', () => {
            const text = textInput.val();
            const voiceName = html.find('[name="tts-voice"]').val();
            
            const validation = TTSValidator.validateTTSRequest(text, voiceName);
            if (!validation.isValid) {
                validation.errors.forEach(error => ui.notifications.warn(error));
                return;
            }

            game.socket.emit(SOCKET_NAME, { 
                type: 'ttsRequest', 
                text: validation.sanitizedText, 
                voiceName,
                userId: game.user.id 
            });

            textInput.val('');
        });
        
        html.find('.tts-stop-all-btn').on('click', () => {
            game.socket.emit(SOCKET_NAME, { type: 'stop' });
        });

        html.find('#tts-volume-slider').on('input', (event) => {
            const volume = $(event.currentTarget).val() / 100;
            game.settings.set(MODULE_ID, 'globalVolume', volume);
            html.find('#tts-volume-value').text(`${Math.round(volume * 100)}%`);
        });
    }

    async close(options) {
        ttsPanelInstance = null;
        return super.close(options);
    }
}


// --- Foundry VTT Hooks ---

Hooks.once('init', () => {
  game.settings.register(MODULE_ID, 'apiKey', {
    name: game.i18n.localize('GEMINI-TTS.Settings.ApiKey.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.ApiKey.Hint'),
    scope: 'world', config: true, type: String, default: '',
  });

  game.settings.register(MODULE_ID, 'enableActorVoices', {
    name: game.i18n.localize('GEMINI-TTS.Settings.EnableActorVoices.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.EnableActorVoices.Hint'),
    scope: 'world', config: true, type: Boolean, default: true,
  });

  game.settings.register(MODULE_ID, 'cacheEnabled', {
    name: game.i18n.localize('GEMINI-TTS.Settings.CacheEnabled.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.CacheEnabled.Hint'),
    scope: 'world', config: true, type: Boolean, default: true,
  });
  
  game.settings.register(MODULE_ID, 'globalVolume', {
    name: game.i18n.localize('GEMINI-TTS.Settings.GlobalVolume.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.GlobalVolume.Hint'),
    scope: 'client', config: true, type: Number, range: { min: 0, max: 1, step: 0.01 }, default: 0.8,
  });

  loadTemplates([
    `modules/${MODULE_ID}/templates/actor-voice-setting.txt`,
    `modules/${MODULE_ID}/templates/tts-panel.txt`
  ]);
});

Hooks.on('renderChatLog', (app, html) => {
  const button = $(`<a class="chat-control-icon gemini-tts-button" title="${game.i18n.localize('GEMINI-TTS.ButtonTitle')}"><i class="fas fa-microphone-alt"></i></a>`);
  button.on('click', () => {
    if (ttsPanelInstance) {
        ttsPanelInstance.render(true);
        ttsPanelInstance.bringToTop();
    } else {
        ttsPanelInstance = new TTSControlPanel().render(true);
    }
  });
  html.find('.chat-controls').prepend(button);
});

Hooks.on('renderActorSheet', async (app, html, data) => {
    if (!game.settings.get(MODULE_ID, 'enableActorVoices')) return;
    const actor = app.actor;
    if (!actor || (!actor.isOwner && !game.user.isGM)) return;
    
    const voices = [
      { key: 'Zephyr', label: game.i18n.localize('GEMINI-TTS.Voices.Zephyr') },
      { key: 'Charon', label: game.i18n.localize('GEMINI-TTS.Voices.Charon') },
      { key: 'Kore', label: game.i18n.localize('GEMINI-TTS.Voices.Kore') },
      { key: 'Puck', label: game.i18n.localize('GEMINI-TTS.Voices.Puck') },
      { key: 'Fenrir', label: game.i18n.localize('GEMINI-TTS.Voices.Fenrir') },
    ];
    
    const preferredVoice = actor.getFlag(MODULE_ID, 'voice') || voices[0].key;

    const templateData = {
        moduleId: MODULE_ID,
        voices: voices.map(v => ({...v, selected: v.key === preferredVoice })),
    };
    
    const renderedTemplate = await renderTemplate(`modules/${MODULE_ID}/templates/actor-voice-setting.txt`, templateData);

    const biographyTab = html.find('.tab[data-tab="biography"]');
    if (biographyTab.length > 0) {
        biographyTab.append(renderedTemplate);
    } else {
        const header = html.find('.window-header, .sheet-header');
        header.after(renderedTemplate);
    }
    
    html.find(`select[name="flags.${MODULE_ID}.voice"]`).on('change', async (event) => {
        await actor.setFlag(MODULE_ID, 'voice', $(event.currentTarget).val());
        ui.notifications.info(`${actor.name}'s voice has been set.`);
    });
});


Hooks.once('ready', () => {
    game.socket.on(SOCKET_NAME, (data) => {
        if (data.type === 'ttsRequest' && game.user.isGM) {
            if (!rateLimiter.canMakeRequest(data.userId)) {
                debugLog(`Rate limit exceeded for user ${data.userId}`);
                game.socket.emit(SOCKET_NAME, { 
                    type: 'notify', 
                    message: game.i18n.localize('GEMINI-TTS.Notifications.RateLimit'),
                    level: 'warning'
                }, { recipients: [data.userId] }); // Foundry handles targeting
                return;
            }
            ttsQueue.add({ text: data.text, voiceName: data.voiceName, requestingUserId: data.userId });
            return;
        }

        switch(data.type) {
            case 'play':
                if (data.audioB64) playAudioFromBase64(data.audioB64);
                break;
            case 'stop':
                stopAllSounds();
                break;
            case 'notify':
                // This client has received a targeted notification from the GM
                ui.notifications[data.level || 'info'](data.message);
                break;
        }
    });
});
```

---

## `README.md`

```markdown
# Gemini TTS for Foundry

Un m贸dulo para Foundry VTT que permite a los usuarios generar audio de texto a voz (Text-to-Speech) de alta calidad utilizando la API de Google Gemini. El audio generado se transmite instant谩neamente a todos los jugadores conectados, proporcionando una herramienta de comunicaci贸n y accesibilidad crucial para jugadores sin micr贸fono o para mejorar la inmersi贸n en la partida.

## Caracter铆sticas

- **Audio de Alta Calidad:** Utiliza los modelos de voz de Google Gemini para una narraci贸n clara y natural.
- **Transmisi贸n en Tiempo Real:** El audio se comparte con todos los jugadores en la sesi贸n a trav茅s de sockets para una experiencia sincronizada.
- **Selecci贸n de Voz:** Permite elegir entre varias voces de Gemini para adaptarse a diferentes personajes o narradores.
- **Integraci贸n Sencilla:** A帽ade un bot贸n de f谩cil acceso directamente en la ventana de chat de Foundry.
- **Configuraci贸n F谩cil:** El Game Master (GM) puede configurar la clave de la API necesaria a trav茅s del men煤 de ajustes del m贸dulo.
- **Voces por Personaje:** Asigna voces por defecto a personajes espec铆ficos desde su ficha de actor.
- **Sistema de Cach茅 y Cola:** Optimiza las llamadas a la API y gestiona m煤ltiples solicitudes de audio de forma fluida.

## Instalaci贸n

1.  En el men煤 principal de Foundry VTT, ve a la pesta帽a **"Setup"**.
2.  Haz clic en el bot贸n **"Add-on Modules"**.
3.  Haz clic en **"Install Module"** en la parte inferior.
4.  En el campo "Manifest URL", copia y pega la siguiente URL:
    ```
    https://github.com/PachonX/gemini-tts-for-foundry/releases/latest/download/module.json
    ```
5.  Haz clic en **"Install"**.

Una vez instalado, no olvides activar el m贸dulo dentro de tu mundo de juego.

## Configuraci贸n (Requerido para el Game Master)

Para que el m贸dulo funcione, el Game Master debe configurar una clave de API de Google Gemini.

1.  Una vez dentro de tu mundo en Foundry, ve al men煤 de la derecha y haz clic en la pesta帽a **"Game Settings"** (el icono del engranaje).
2.  Haz clic en el bot贸n **"Configure Settings"**.
3.  Selecciona la pesta帽a **"Module Settings"**.
4.  Busca la secci贸n correspondiente a **"Gemini TTS for Foundry"**.
5.  En el campo llamado **"Google Gemini API Key"**, pega tu clave de API. Puedes obtener una desde [Google AI Studio](https://aistudio.google.com/app/apikey).
6.  Haz clic en **"Save Changes"** en la parte inferior.

隆El m贸dulo ya est谩 listo para ser utilizado por todos los jugadores!

## 驴C贸mo se Usa? (Para Jugadores)

Cualquier jugador en la partida puede generar audio:

1.  En la ventana de chat, haz clic en el nuevo **铆cono de micr贸fono** que aparece en la barra de controles.
2.  Se abrir谩 una ventana emergente titulada "Generate Speech with Gemini".
3.  Escribe el texto que deseas que se hable en el cuadro de texto.
4.  Selecciona una de las voces disponibles en el men煤 desplegable. Si tu personaje tiene una voz asignada, se seleccionar谩 autom谩ticamente.
5.  Haz clic en el bot贸n **"Speak"**.

El audio se generar谩 y se reproducir谩 autom谩ticamente para todos los jugadores en la partida.

---

### **Nota para Desarrolladores**

Este proyecto utiliza un workaround para la compatibilidad con el entorno de desarrollo. Los archivos de plantilla de Handlebars (`.hbs`) se guardan en el repositorio como archivos `.txt`.

**Acci贸n Requerida antes de Publicar:** Antes de crear una nueva release o empaquetar el m贸dulo, debes renombrar los siguientes archivos en la carpeta `templates/`:
- `actor-voice-setting.txt` -> `actor-voice-setting.hbs`
- `tts-panel.txt` -> `tts-panel.hbs`
```

---

## `roadmap.md`

```markdown
# Roadmap de "Gemini TTS for Foundry"

Este documento describe las futuras mejoras y caracter铆sticas planificadas para el m贸dulo, basadas en las excelentes sugerencias de la comunidad.

##  Pr贸ximas Funcionalidades

### 1. Sistema de Macros y Automatizaci贸n
- [ ] **Crear una API externa**: Exponer funciones como `game.modules.get('gemini-tts-for-foundry').api.speakAsCharacter(actorId, text)` para permitir que otros m贸dulos y macros activen el TTS de forma program谩tica.
- [ ] **Documentar la API**: Proporcionar ejemplos claros de c贸mo usar la API para automatizar la narraci贸n o los di谩logos de los personajes.

### 2. Soporte para M煤ltiples Proveedores de TTS
- [ ] **Abstraer el servicio de TTS**: Refactorizar el c贸digo para desacoplar la l贸gica de la API de Gemini y permitir la integraci贸n de otros proveedores (como ElevenLabs, OpenAI TTS, etc.).
- [ ] **A帽adir configuraci贸n de proveedor**: Incluir una opci贸n en los ajustes del m贸dulo para que el GM elija qu茅 servicio de TTS utilizar.

### 3. Interfaz de Usuario Mejorada (Panel de Control)
- [x] **Panel de control flotante**: Reemplazar el di谩logo modal con una ventana `Application` flotante que puede permanecer abierta.
- [x] **Controles avanzados**: A帽adir controles de volumen global, un bot贸n de "parar todo el audio", y una vista de la cola de TTS actual.

### 4. Sistema de Efectos de Sonido y Modulaci贸n
- [ ] **Integraci贸n con la Web Audio API**: Implementar una clase `AudioEffects` para procesar el audio antes de reproducirlo.
- [ ] **Efectos configurables**: A帽adir opciones en el di谩logo de TTS para aplicar efectos b谩sicos como cambio de tono (pitch shift) o reverberaci贸n, 煤tiles para voces de monstruos o ambientes espec铆ficos.

### 5. Integraci贸n con el Sistema de Escenas
- [ ] **Audio ambiental por escena**: Permitir al GM configurar un texto y una voz para que se reproduzca en bucle como ambiente sonoro cuando una escena se activa.
- [ ] **Triggers de audio**: Explorar la posibilidad de vincular audios de TTS a zonas espec铆ficas del mapa (usando m贸dulos como Multilevel Tokens o Trigger Happy).

### 6. Sistema de Plantillas de Di谩logo
- [ ] **Interfaz para plantillas**: Crear una UI donde los GMs puedan definir y guardar plantillas de frases comunes (ej. ataques, hechizos, interacciones sociales).
- [ ] **Acceso r谩pido**: Integrar un selector de plantillas en el di谩logo de TTS para una selecci贸n r谩pida.

### 7. Sistema de Filtros de Contenido
- [ ] **A帽adir ajuste de filtro**: Implementar la configuraci贸n `contentFilterLevel` (Ninguno, Est谩ndar, Estricto) sugerida.
- [ ] **L贸gica de filtrado**: Crear una funci贸n `ContentFilter` que procese el texto antes de enviarlo a la API para reemplazar palabras o frases no deseadas.

### 8. M茅tricas y Analytics (Opcional)
- [ ] **Mecanismo de opt-in**: A帽adir una opci贸n de configuraci贸n para que los GMs puedan habilitar el env铆o an贸nimo de m茅tricas de uso.
- [ ] **Recopilaci贸n de datos b谩sicos**: Registrar eventos como `generacion_exitosa`, `error_api`, `cache_hit` para ayudar a identificar problemas y priorizar mejoras.
```

---

## `templates/actor-voice-setting.txt`

```html
<div class="form-group gemini-tts-actor-voice">
    <label for="gemini-tts-voice-select">{{localize "GEMINI-TTS.ActorVoiceLabel"}}</label>
    <select name="flags.{{moduleId}}.voice" id="gemini-tts-voice-select">
        {{#each voices}}
        <option value="{{this.key}}" {{#if this.selected}}selected{{/if}}>{{this.label}}</option>
        {{/each}}
    </select>
</div>
```

---

## `templates/tts-panel.txt`

```html
<div class="form-group">
    <label for="tts-text">{{localize "GEMINI-TTS.TextPlaceholder"}}</label>
    <textarea name="tts-text" id="tts-text" rows="4" placeholder="{{localize 'GEMINI-TTS.TextPlaceholder'}}"></textarea>
</div>

<div class="form-group">
    <label for="tts-voice">{{localize "GEMINI-TTS.VoiceLabel"}}</label>
    <select name="tts-voice" id="tts-voice">
        {{#each voices}}
        <option value="{{this.key}}" {{#if this.selected}}selected{{/if}}>{{this.label}}</option>
        {{/each}}
    </select>
</div>

<div class="form-group">
    <label for="tts-volume-slider">{{localize "GEMINI-TTS.VolumeLabel"}} <span id="tts-volume-value">{{volume}}%</span></label>
    <input type="range" id="tts-volume-slider" min="0" max="100" value="{{volume}}" class="slider">
</div>

<div class.panel-controls">
    <button class="tts-speak-btn"><i class="fas fa-microphone-alt"></i> {{localize "GEMINI-TTS.SpeakButton"}}</button>
    <button class="tts-stop-all-btn" style="background-color: #c9302c;"><i class="fas fa-stop-circle"></i> {{localize "GEMINI-TTS.StopAllButton"}}</button>
</div>

<div class="tts-queue">
    <h4><i class="fas fa-list-ol"></i> {{localize "GEMINI-TTS.QueueTitle"}}</h4>
    <ol class="tts-queue-list">
        {{#if queue.length}}
            {{#each queue}}
            <li title="{{this.text}}">{{this.text}}</li>
            {{/each}}
        {{else}}
            <li>&nbsp;</li>
        {{/if}}
    </ol>
</div>
```