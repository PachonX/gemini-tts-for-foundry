<!-- markdown que recopila todo el codigo del proyecto para anÃ¡lisis -->

# CÃ³digo Completo del MÃ³dulo: Gemini TTS for Foundry

Este documento contiene una copia completa de todos los archivos de cÃ³digo fuente del mÃ³dulo "Gemini TTS for Foundry" para facilitar su revisiÃ³n y anÃ¡lisis.

---

## `module.json`

```json
{
  "id": "gemini-tts-for-foundry",
  "title": "Gemini TTS for Foundry",
  "description": "Allows users to generate text-to-speech audio using the Google Gemini API and broadcast it to all players, providing a crucial communication tool for players without a microphone.",
  "version": "1.3.0",
  "authors": [
    {
      "name": "Gemini Assistant"
    }
  ],
  "compatibility": {
    "minimum": "11",
    "verified": "12"
  },
  "esmodules": [
    "main.js"
  ],
  "styles": [
    "styles/style.css"
  ],
  "languages": [
    {
      "lang": "en",
      "name": "English",
      "path": "lang/en.json"
    }
  ],
  "templates": [
    "templates/actor-voice-setting.txt",
    "templates/tts-panel.txt"
  ],
  "socket": true
}
```

---

## `lang/en.json`

```json
{
  "GEMINI-TTS": {
    "ButtonTitle": "Gemini Text-to-Speech",
    "DialogTitle": "Generate Speech with Gemini",
    "PanelTitle": "TTS Control Panel",
    "TextPlaceholder": "Enter text to speak...",
    "VoiceLabel": "Select Voice",
    "SpeakButton": "Speak",
    "CancelButton": "Cancel",
    "StopAllButton": "Stop All Audio",
    "VolumeLabel": "Global Volume",
    "QueueTitle": "Audio Queue",
    "ActorVoiceLabel": "Gemini TTS Voice",
    "Notifications": {
      "ApiKeyMissing": "Gemini API Key is not configured. Please set it in the module settings.",
      "ApiError": "Gemini API Error: {error}",
      "ApiErrorQuota": "API quota limit exceeded. Please try again later.",
      "ApiErrorNetwork": "Connection error. Please check your internet connection.",
      "ApiErrorInvalidKey": "Invalid or missing API key. The GM must configure it.",
      "EmptyText": "Cannot speak an empty text.",
      "Generating": "Generating audio...",
      "RateLimit": "You have reached the TTS request limit. Please wait a moment.",
      "ValidationErrorTooLong": "Text is too long (max 5000 characters)."
    },
    "Voices": {
      "Zephyr": "Zephyr (Female)",
      "Charon": "Charon (Deep Male)",
      "Kore": "Kore (Female)",
      "Puck": "Puck (Youthful Male)",
      "Fenrir": "Fenrir (Mature Male)"
    },
    "Settings": {
      "ApiKey": {
        "Name": "Google Gemini API Key",
        "Hint": "Enter your API Key for the Google Gemini Generative Language API."
      },
      "EnableActorVoices": {
        "Name": "Enable Actor-specific Voices",
        "Hint": "If enabled, allows assigning a default TTS voice to each character in their sheet."
      },
      "CacheEnabled": {
        "Name": "Enable Audio Caching",
        "Hint": "If enabled, frequently used phrases will be cached to reduce API calls and improve speed."
      },
      "GlobalVolume": {
        "Name": "Global TTS Volume",
        "Hint": "Controls the master volume for all audio generated by Gemini TTS."
      }
    }
  }
}
```

---

## `styles/style.css`

```css
.chat-control-icon.gemini-tts-button {
  margin-left: 5px;
}

/* New TTS Control Panel Styles */
.gemini-tts-panel {
    min-width: 350px;
    min-height: 400px;
}

.gemini-tts-panel .window-content {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.gemini-tts-panel .form-group {
    display: flex;
    flex-direction: column;
}

.gemini-tts-panel label {
    font-weight: bold;
    margin-bottom: 5px;
}

.gemini-tts-panel textarea {
    width: 100%;
    height: 100px;
    resize: vertical;
    box-sizing: border-box;
}

.gemini-tts-panel select, .gemini-tts-panel input[type="range"] {
    width: 100%;
    box-sizing: border-box;
}

.gemini-tts-panel .panel-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.gemini-tts-panel .panel-controls button {
    flex-grow: 1;
}

.gemini-tts-panel .tts-queue {
    border-top: 1px solid #CCC;
    padding-top: 10px;
    margin-top: 10px;
    flex-grow: 1;
}

.gemini-tts-panel .tts-queue h4 {
    margin-top: 0;
    margin-bottom: 10px;
    border-bottom: 1px solid #DDD;
    padding-bottom: 5px;
}

.gemini-tts-panel .tts-queue-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
    max-height: 150px;
    overflow-y: auto;
}

.gemini-tts-panel .tts-queue-list li {
    background: rgba(0, 0, 0, 0.05);
    padding: 5px 8px;
    border-radius: 3px;
    margin-bottom: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9em;
}


/* Styles for Actor Sheet Integration */
.gemini-tts-actor-voice {
    padding: 10px;
    border-top: 1px solid #CCC;
    margin-top: 10px;
}

.gemini-tts-actor-voice .form-group {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
}

.gemini-tts-actor-voice label {
    font-weight: bold;
    margin-right: 10px;
    flex-shrink: 0;
}

.gemini-tts-actor-voice select {
    flex-grow: 1;
}
```

---

## `main.js`

```javascript
const MODULE_ID = 'gemini-tts-for-foundry';
const SOCKET_NAME = `module.${MODULE_ID}`;

const DEBUG = false; // Set to true for verbose debugging in the console

let ttsPanelInstance = null;
let activeSounds = new Set();

function debugLog(...args) {
    if (DEBUG) {
        console.log(`[${MODULE_ID}] |`, ...args);
    }
}

// --- System Classes (Validation, Rate Limiting, Cache, Queue) ---

class TTSValidator {
  static validateTTSRequest(text, voiceName) {
    const errors = [];
    
    if (!text || text.trim().length === 0) {
      errors.push(game.i18n.localize('GEMINI-TTS.Notifications.EmptyText'));
    }
    
    if (text.length > 5000) {
      errors.push(game.i18n.localize('GEMINI-TTS.Notifications.ValidationErrorTooLong'));
    }
    
    const validVoices = ['Zephyr', 'Charon', 'Kore', 'Puck', 'Fenrir'];
    if (!validVoices.includes(voiceName)) {
      errors.push("Invalid voice selected.");
    }
    
    const sanitizedText = text.trim().substring(0, 5000);
    
    return {
      isValid: errors.length === 0,
      errors,
      sanitizedText
    };
  }
}

class TTSRateLimiter {
  constructor() {
    this.requests = new Map();
    this.maxRequestsPerMinute = 30;
  }
  
  canMakeRequest(userId) {
    const now = Date.now();
    const userRequests = this.requests.get(userId) || [];
    
    const recentRequests = userRequests.filter(time => now - time < 60000);
    
    if (recentRequests.length >= this.maxRequestsPerMinute) {
      return false;
    }
    
    recentRequests.push(now);
    this.requests.set(userId, recentRequests);
    return true;
  }
}

class TTSCache {
  constructor() {
    this.cache = new Map();
    this.maxSize = 100;
  }

  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  getKey(text, voice) {
    const hash = this.simpleHash(text);
    return `${voice}-${hash}-${text.length}`;
  }

  get(text, voice) {
    return this.cache.get(this.getKey(text, voice));
  }

  set(text, voice, audioB64) {
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(this.getKey(text, voice), audioB64);
  }
}

class TTSQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  add(request) {
    this.queue.push(request);
    if (ttsPanelInstance) ttsPanelInstance.render(false);
    this.process();
  }

  async process() {
    if (this.processing || this.queue.length === 0) return;
    if (!game.user.isGM) return; // Double security check

    this.processing = true;
    const { text, voiceName, requestingUserId } = this.queue.shift();
    debugLog('Processing TTS request:', `"${text.substring(0, 50)}..."`, 'for user', requestingUserId);
    if (ttsPanelInstance) ttsPanelInstance.render(false);

    try {
      const apiKey = game.settings.get(MODULE_ID, 'apiKey');
      if (!apiKey) throw new Error(game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorInvalidKey'));
      
      let audioB64;
      const useCache = game.settings.get(MODULE_ID, 'cacheEnabled');

      if (useCache) {
          audioB64 = ttsCache.get(text, voiceName);
          if (audioB64) debugLog('Cache hit for request.');
      }

      if (!audioB64) {
        debugLog('Cache miss. Calling Gemini API.');
        ui.notifications.info(game.i18n.localize('GEMINI-TTS.Notifications.Generating'));
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: text }] }],
                config: {
                    responseModalities: ['AUDIO'],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } } }
                }
            })
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error.message || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        audioB64 = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;

        if (useCache && audioB64) {
            ttsCache.set(text, voiceName, audioB64);
            debugLog('Saved new audio to cache.');
        }
      }

      if (audioB64) {
        game.socket.emit(SOCKET_NAME, { type: 'play', audioB64 });
      } else {
        throw new Error("No audio data received from API.");
      }

    } catch (err) {
      console.error(`${MODULE_ID} | API Error:`, err);
      let userMessage;
      const errorStr = err.message.toLowerCase();
      
      if (errorStr.includes('quota') || errorStr.includes('429')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorQuota');
      } else if (errorStr.includes('network') || errorStr.includes('fetch')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorNetwork');
      } else if (errorStr.includes('api key') || errorStr.includes('403')) {
        userMessage = game.i18n.localize('GEMINI-TTS.Notifications.ApiErrorInvalidKey');
      } else {
        userMessage = err.message;
      }

      if (game.user.isGM) {
        ui.notifications.error(game.i18n.format('GEMINI-TTS.Notifications.ApiError', { error: userMessage }));
      }
    } finally {
      this.processing = false;
      setTimeout(() => this.process(), 100); 
    }
  }
}

const ttsCache = new TTSCache();
const ttsQueue = game.user.isGM ? new TTSQueue() : null;
const rateLimiter = game.user.isGM ? new TTSRateLimiter() : null;

// --- Audio Playback ---

function decodeBase64(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

function createWavHeader(pcmDataLength) {
  const sampleRate = 24000;
  const numChannels = 1;
  const bitsPerSample = 16;
  const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
  const blockAlign = numChannels * (bitsPerSample / 8);

  const buffer = new ArrayBuffer(44);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + pcmDataLength, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);
  writeString(view, 36, 'data');
  view.setUint32(40, pcmDataLength, true);

  return new Uint8Array(buffer);
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

async function playAudioFromBase64(base64Data) {
    let url;
    try {
        const pcmData = decodeBase64(base64Data);
        const wavHeader = createWavHeader(pcmData.length);
        const wavData = new Uint8Array(wavHeader.length + pcmData.length);
        
        wavData.set(wavHeader, 0);
        wavData.set(pcmData, wavHeader.length);

        const blob = new Blob([wavData], { type: 'audio/wav' });
        url = URL.createObjectURL(blob);
        
        const volume = game.settings.get(MODULE_ID, 'globalVolume');
        const sound = await AudioHelper.play({ src: url, volume: volume, autoplay: true, loop: false }, false);
        
        if (sound) {
            activeSounds.add(sound);
            const onEnd = () => {
                activeSounds.delete(sound);
                URL.revokeObjectURL(url);
                debugLog('Audio ended and URL revoked.');
            };
            sound.on('end', onEnd);
            sound.on('error', onEnd);
        } else {
            URL.revokeObjectURL(url);
            debugLog('Sound object creation failed, URL revoked.');
        }
    } catch (error) {
        if (url) URL.revokeObjectURL(url);
        console.error(`${MODULE_ID} | Audio playback error:`, error);
    }
}

function stopAllSounds() {
    activeSounds.forEach(sound => {
        sound.stop();
    });
    activeSounds.clear();
    debugLog('All sounds stopped via stopAllSounds()');
}


// --- UI & Control Panel ---

class TTSControlPanel extends Application {
    static get defaultOptions() {
        return mergeObject(super.defaultOptions, {
            id: 'gemini-tts-panel',
            classes: ['gemini-tts-panel'],
            template: `modules/${MODULE_ID}/templates/tts-panel.txt`,
            title: game.i18n.localize('GEMINI-TTS.PanelTitle'),
            width: 400,
            height: 'auto',
            resizable: true,
        });
    }

    getData() {
        const voices = [
            { key: 'Zephyr', label: game.i18n.localize('GEMINI-TTS.Voices.Zephyr') },
            { key: 'Charon', label: game.i18n.localize('GEMINI-TTS.Voices.Charon') },
            { key: 'Kore', label: game.i18n.localize('GEMINI-TTS.Voices.Kore') },
            { key: 'Puck', label: game.i18n.localize('GEMINI-TTS.Voices.Puck') },
            { key: 'Fenrir', label: game.i18n.localize('GEMINI-TTS.Voices.Fenrir') },
        ];
        
        const preferredVoice = game.settings.get(MODULE_ID, 'enableActorVoices') 
            ? game.user.character?.getFlag(MODULE_ID, 'voice') 
            : null;
        
        const queue = game.user.isGM && ttsQueue ? ttsQueue.queue : [];
            
        return {
            voices: voices.map(v => ({...v, selected: v.key === preferredVoice })),
            queue: queue,
            volume: game.settings.get(MODULE_ID, 'globalVolume') * 100
        };
    }

    activateListeners(html) {
        super.activateListeners(html);
        const textInput = html.find('[name="tts-text"]');
        
        html.find('.tts-speak-btn').on('click', () => {
            const text = textInput.val();
            const voiceName = html.find('[name="tts-voice"]').val();
            
            const validation = TTSValidator.validateTTSRequest(text, voiceName);
            if (!validation.isValid) {
                validation.errors.forEach(error => ui.notifications.warn(error));
                return;
            }

            game.socket.emit(SOCKET_NAME, { 
                type: 'ttsRequest', 
                text: validation.sanitizedText, 
                voiceName,
                userId: game.user.id 
            });

            textInput.val('');
        });
        
        html.find('.tts-stop-all-btn').on('click', () => {
            game.socket.emit(SOCKET_NAME, { type: 'stop' });
        });

        html.find('#tts-volume-slider').on('input', (event) => {
            const volume = $(event.currentTarget).val() / 100;
            game.settings.set(MODULE_ID, 'globalVolume', volume);
            html.find('#tts-volume-value').text(`${Math.round(volume * 100)}%`);
        });
    }

    async close(options) {
        ttsPanelInstance = null;
        return super.close(options);
    }
}


// --- Foundry VTT Hooks ---

Hooks.once('init', () => {
  game.settings.register(MODULE_ID, 'apiKey', {
    name: game.i18n.localize('GEMINI-TTS.Settings.ApiKey.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.ApiKey.Hint'),
    scope: 'world', config: true, type: String, default: '',
  });

  game.settings.register(MODULE_ID, 'enableActorVoices', {
    name: game.i18n.localize('GEMINI-TTS.Settings.EnableActorVoices.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.EnableActorVoices.Hint'),
    scope: 'world', config: true, type: Boolean, default: true,
  });

  game.settings.register(MODULE_ID, 'cacheEnabled', {
    name: game.i18n.localize('GEMINI-TTS.Settings.CacheEnabled.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.CacheEnabled.Hint'),
    scope: 'world', config: true, type: Boolean, default: true,
  });
  
  game.settings.register(MODULE_ID, 'globalVolume', {
    name: game.i18n.localize('GEMINI-TTS.Settings.GlobalVolume.Name'),
    hint: game.i18n.localize('GEMINI-TTS.Settings.GlobalVolume.Hint'),
    scope: 'client', config: true, type: Number, range: { min: 0, max: 1, step: 0.01 }, default: 0.8,
  });

  loadTemplates([
    `modules/${MODULE_ID}/templates/actor-voice-setting.txt`,
    `modules/${MODULE_ID}/templates/tts-panel.txt`
  ]);
});

Hooks.on('renderChatLog', (app, html) => {
  const button = $(`<a class="chat-control-icon gemini-tts-button" title="${game.i18n.localize('GEMINI-TTS.ButtonTitle')}"><i class="fas fa-microphone-alt"></i></a>`);
  button.on('click', () => {
    if (ttsPanelInstance) {
        ttsPanelInstance.render(true);
        ttsPanelInstance.bringToTop();
    } else {
        ttsPanelInstance = new TTSControlPanel().render(true);
    }
  });
  html.find('.chat-controls').prepend(button);
});

Hooks.on('renderActorSheet', async (app, html, data) => {
    if (!game.settings.get(MODULE_ID, 'enableActorVoices')) return;
    const actor = app.actor;
    if (!actor || (!actor.isOwner && !game.user.isGM)) return;
    
    const voices = [
      { key: 'Zephyr', label: game.i18n.localize('GEMINI-TTS.Voices.Zephyr') },
      { key: 'Charon', label: game.i18n.localize('GEMINI-TTS.Voices.Charon') },
      { key: 'Kore', label: game.i18n.localize('GEMINI-TTS.Voices.Kore') },
      { key: 'Puck', label: game.i18n.localize('GEMINI-TTS.Voices.Puck') },
      { key: 'Fenrir', label: game.i18n.localize('GEMINI-TTS.Voices.Fenrir') },
    ];
    
    const preferredVoice = actor.getFlag(MODULE_ID, 'voice') || voices[0].key;

    const templateData = {
        moduleId: MODULE_ID,
        voices: voices.map(v => ({...v, selected: v.key === preferredVoice })),
    };
    
    const renderedTemplate = await renderTemplate(`modules/${MODULE_ID}/templates/actor-voice-setting.txt`, templateData);

    const biographyTab = html.find('.tab[data-tab="biography"]');
    if (biographyTab.length > 0) {
        biographyTab.append(renderedTemplate);
    } else {
        const header = html.find('.window-header, .sheet-header');
        header.after(renderedTemplate);
    }
    
    html.find(`select[name="flags.${MODULE_ID}.voice"]`).on('change', async (event) => {
        await actor.setFlag(MODULE_ID, 'voice', $(event.currentTarget).val());
        ui.notifications.info(`${actor.name}'s voice has been set.`);
    });
});


Hooks.once('ready', () => {
    game.socket.on(SOCKET_NAME, (data) => {
        if (data.type === 'ttsRequest' && game.user.isGM) {
            if (!rateLimiter.canMakeRequest(data.userId)) {
                debugLog(`Rate limit exceeded for user ${data.userId}`);
                game.socket.emit(SOCKET_NAME, { 
                    type: 'notify', 
                    message: game.i18n.localize('GEMINI-TTS.Notifications.RateLimit'),
                    level: 'warning'
                }, { recipients: [data.userId] }); // Foundry handles targeting
                return;
            }
            ttsQueue.add({ text: data.text, voiceName: data.voiceName, requestingUserId: data.userId });
            return;
        }

        switch(data.type) {
            case 'play':
                if (data.audioB64) playAudioFromBase64(data.audioB64);
                break;
            case 'stop':
                stopAllSounds();
                break;
            case 'notify':
                // This client has received a targeted notification from the GM
                ui.notifications[data.level || 'info'](data.message);
                break;
        }
    });
});
```

---

## `README.md`

```markdown
# Gemini TTS for Foundry

Un mÃ³dulo para Foundry VTT que permite a los usuarios generar audio de texto a voz (Text-to-Speech) de alta calidad utilizando la API de Google Gemini. El audio generado se transmite instantÃ¡neamente a todos los jugadores conectados, proporcionando una herramienta de comunicaciÃ³n y accesibilidad crucial para jugadores sin micrÃ³fono o para mejorar la inmersiÃ³n en la partida.

## CaracterÃ­sticas

- **Audio de Alta Calidad:** Utiliza los modelos de voz de Google Gemini para una narraciÃ³n clara y natural.
- **TransmisiÃ³n en Tiempo Real:** El audio se comparte con todos los jugadores en la sesiÃ³n a travÃ©s de sockets para una experiencia sincronizada.
- **SelecciÃ³n de Voz:** Permite elegir entre varias voces de Gemini para adaptarse a diferentes personajes o narradores.
- **IntegraciÃ³n Sencilla:** AÃ±ade un botÃ³n de fÃ¡cil acceso directamente en la ventana de chat de Foundry.
- **ConfiguraciÃ³n FÃ¡cil:** El Game Master (GM) puede configurar la clave de la API necesaria a travÃ©s del menÃº de ajustes del mÃ³dulo.
- **Voces por Personaje:** Asigna voces por defecto a personajes especÃ­ficos desde su ficha de actor.
- **Sistema de CachÃ© y Cola:** Optimiza las llamadas a la API y gestiona mÃºltiples solicitudes de audio de forma fluida.

## InstalaciÃ³n

1.  En el menÃº principal de Foundry VTT, ve a la pestaÃ±a **"Setup"**.
2.  Haz clic en el botÃ³n **"Add-on Modules"**.
3.  Haz clic en **"Install Module"** en la parte inferior.
4.  En el campo "Manifest URL", copia y pega la siguiente URL:
    ```
    https://github.com/PachonX/gemini-tts-for-foundry/releases/latest/download/module.json
    ```
5.  Haz clic en **"Install"**.

Una vez instalado, no olvides activar el mÃ³dulo dentro de tu mundo de juego.

## ConfiguraciÃ³n (Requerido para el Game Master)

Para que el mÃ³dulo funcione, el Game Master debe configurar una clave de API de Google Gemini.

1.  Una vez dentro de tu mundo en Foundry, ve al menÃº de la derecha y haz clic en la pestaÃ±a **"Game Settings"** (el icono del engranaje).
2.  Haz clic en el botÃ³n **"Configure Settings"**.
3.  Selecciona la pestaÃ±a **"Module Settings"**.
4.  Busca la secciÃ³n correspondiente a **"Gemini TTS for Foundry"**.
5.  En el campo llamado **"Google Gemini API Key"**, pega tu clave de API. Puedes obtener una desde [Google AI Studio](https://aistudio.google.com/app/apikey).
6.  Haz clic en **"Save Changes"** en la parte inferior.

Â¡El mÃ³dulo ya estÃ¡ listo para ser utilizado por todos los jugadores!

## Â¿CÃ³mo se Usa? (Para Jugadores)

Cualquier jugador en la partida puede generar audio:

1.  En la ventana de chat, haz clic en el nuevo **Ã­cono de micrÃ³fono** que aparece en la barra de controles.
2.  Se abrirÃ¡ una ventana emergente titulada "Generate Speech with Gemini".
3.  Escribe el texto que deseas que se hable en el cuadro de texto.
4.  Selecciona una de las voces disponibles en el menÃº desplegable. Si tu personaje tiene una voz asignada, se seleccionarÃ¡ automÃ¡ticamente.
5.  Haz clic en el botÃ³n **"Speak"**.

El audio se generarÃ¡ y se reproducirÃ¡ automÃ¡ticamente para todos los jugadores en la partida.

---

### **Nota para Desarrolladores**

Este proyecto utiliza un workaround para la compatibilidad con el entorno de desarrollo. Los archivos de plantilla de Handlebars (`.hbs`) se guardan en el repositorio como archivos `.txt`.

**AcciÃ³n Requerida antes de Publicar:** Antes de crear una nueva release o empaquetar el mÃ³dulo, debes renombrar los siguientes archivos en la carpeta `templates/`:
- `actor-voice-setting.txt` -> `actor-voice-setting.hbs`
- `tts-panel.txt` -> `tts-panel.hbs`
---

# CHANGELOG - Gemini TTS for Foundry

## [v1.3.0] - 2024-XX-XX

### ğŸš€ **Nuevas CaracterÃ­sticas**

#### **Seguridad y Arquitectura**
- ğŸ”’ **Arquitectura segura GM-centralizada**: Solo el Game Master realiza llamadas a la API
- ğŸ›¡ï¸ **ProtecciÃ³n de credenciales**: La API Key nunca se expone a los jugadores
- âš¡ **Sistema de rate limiting**: LÃ­mite de 30 solicitudes por minuto por usuario
- âœ… **ValidaciÃ³n robusta**: SanitizaciÃ³n de texto y lÃ­mites de caracteres (5000 max)

#### **Interfaz de Usuario Mejorada**
- ğŸ›ï¸ **Panel de control flotante**: Reemplaza el diÃ¡logo modal por ventana persistente
- ğŸ“‹ **Cola visual de audio**: Los usuarios ven el estado de sus solicitudes pendientes
- ğŸ”Š **Control de volumen global**: Ajuste maestro para todos los audios TTS
- â¹ï¸ **BotÃ³n "Stop All Audio"**: Detiene inmediatamente toda reproducciÃ³n
- ğŸ­ **IntegraciÃ³n en fichas de actor**: ConfiguraciÃ³n de voces por personaje

#### **Rendimiento y OptimizaciÃ³n**
- ğŸ’¾ **Sistema de cache inteligente**: Almacena audios frecuentes con hash eficiente
- ğŸ”„ **Procesamiento en cola**: Maneja mÃºltiples solicitudes simultÃ¡neas
- ğŸ§¹ **GestiÃ³n de memoria**: LiberaciÃ³n automÃ¡tica de URLs de audio
- ğŸ› **Sistema de debug**: Logging opcional para troubleshooting

### ğŸ¯ **Mejoras de Experiencia**

#### **Para el Game Master**
- ğŸ¤– **Proceso completamente automÃ¡tico**: CERO popups de confirmaciÃ³n
- â±ï¸ **Sin interrupciones**: El GM puede seguir jugando sin molestias
- ğŸ“Š **Control total**: Monitoreo de uso y prevenciÃ³n de abusos
- ğŸ’° **Control de costos**: Una sola llamada API por solicitud

#### **Para los Jugadores**
- ğŸ¨ **Interfaz intuitiva**: Panel de control fÃ¡cil de usar
- â³ **Feedback visual**: Ver la cola de audios pendientes
- ğŸµ **Experiencia consistente**: Audio sincronizado para todos los jugadores
- ğŸ”§ **PersonalizaciÃ³n**: Voces especÃ­ficas por personaje

### ğŸ”§ **Cambios TÃ©cnicos**

#### **Arquitectura**
- ğŸ”„ **Sistema de sockets**: ComunicaciÃ³n bidireccional segura
- ğŸ—ï¸ **Clases modulares**: Validator, RateLimiter, Cache, Queue
- ğŸŒ **Manejo de errores**: ClasificaciÃ³n inteligente de errores de API
- ğŸ“¡ **TransmisiÃ³n eficiente**: Audio enviado una vez, reproducido en todos los clientes

#### **ConfiguraciÃ³n**
- âš™ï¸ **Settings expandidos**: 
  - API Key (solo GM)
  - Habilitar voces por actor
  - Cache habilitado/deshabilitado
  - Volumen global TTS

### ğŸ› **Correcciones de Errores**

- **GestiÃ³n de memoria**: URLs de Blob liberadas correctamente
- **Manejo de errores**: Notificaciones especÃ­ficas por tipo de error
- **ValidaciÃ³n de entrada**: PrevenciÃ³n de textos vacÃ­os o demasiado largos
- **SincronizaciÃ³n**: ReproducciÃ³n consistente en todos los clientes

### ğŸ“ˆ **Compatibilidad**

- âœ… **Foundry VTT**: Versiones 11-12 verificadas
- âœ… **Sistemas**: Compatible con todos los sistemas de juego
- âœ… **MÃ³dulos**: No presenta conflictos conocidos

---

## [v1.0.0] - 2024-XX-XX
### **Lanzamiento Inicial**
- Funcionalidad bÃ¡sica de Text-to-Speech con Gemini API
- DiÃ¡logo simple para generar audio
- TransmisiÃ³n bÃ¡sica a todos los jugadores

---

**Â¿Listo para actualizar?** Simplemente instala la nueva versiÃ³n y configura tu API Key en los ajustes del mÃ³dulo. Â¡El GM no necesita hacer nada mÃ¡s - el sistema funciona automÃ¡ticamente! ğŸ‰

*Nota: Los usuarios de versiones anteriores pueden actualizar sin problemas - todas las configuraciones se mantienen.*
```

---

## `roadmap.md`

```markdown
# Roadmap de "Gemini TTS for Foundry"

Este documento describe las futuras mejoras y caracterÃ­sticas planificadas para el mÃ³dulo, basadas en las excelentes sugerencias de la comunidad.

## ğŸš€ PrÃ³ximas Funcionalidades

### 1. Sistema de Macros y AutomatizaciÃ³n
- [ ] **Crear una API externa**: Exponer funciones como `game.modules.get('gemini-tts-for-foundry').api.speakAsCharacter(actorId, text)` para permitir que otros mÃ³dulos y macros activen el TTS de forma programÃ¡tica.
- [ ] **Documentar la API**: Proporcionar ejemplos claros de cÃ³mo usar la API para automatizar la narraciÃ³n o los diÃ¡logos de los personajes.

### 2. Soporte para MÃºltiples Proveedores de TTS
- [ ] **Abstraer el servicio de TTS**: Refactorizar el cÃ³digo para desacoplar la lÃ³gica de la API de Gemini y permitir la integraciÃ³n de otros proveedores (como ElevenLabs, OpenAI TTS, etc.).
- [ ] **AÃ±adir configuraciÃ³n de proveedor**: Incluir una opciÃ³n en los ajustes del mÃ³dulo para que el GM elija quÃ© servicio de TTS utilizar.

### 3. Interfaz de Usuario Mejorada (Panel de Control)
- [x] **Panel de control flotante**: Reemplazar el diÃ¡logo modal con una ventana `Application` flotante que puede permanecer abierta.
- [x] **Controles avanzados**: AÃ±adir controles de volumen global, un botÃ³n de "parar todo el audio", y una vista de la cola de TTS actual.

### 4. Sistema de Efectos de Sonido y ModulaciÃ³n
- [ ] **IntegraciÃ³n con la Web Audio API**: Implementar una clase `AudioEffects` para procesar el audio antes de reproducirlo.
- [ ] **Efectos configurables**: AÃ±adir opciones en el diÃ¡logo de TTS para aplicar efectos bÃ¡sicos como cambio de tono (pitch shift) o reverberaciÃ³n, Ãºtiles para voces de monstruos o ambientes especÃ­ficos.

### 5. IntegraciÃ³n con el Sistema de Escenas
- [ ] **Audio ambiental por escena**: Permitir al GM configurar un texto y una voz para que se reproduzca en bucle como ambiente sonoro cuando una escena se activa.
- [ ] **Triggers de audio**: Explorar la posibilidad de vincular audios de TTS a zonas especÃ­ficas del mapa (usando mÃ³dulos como Multilevel Tokens o Trigger Happy).

### 6. Sistema de Plantillas de DiÃ¡logo
- [ ] **Interfaz para plantillas**: Crear una UI donde los GMs puedan definir y guardar plantillas de frases comunes (ej. ataques, hechizos, interacciones sociales).
- [ ] **Acceso rÃ¡pido**: Integrar un selector de plantillas en el diÃ¡logo de TTS para una selecciÃ³n rÃ¡pida.

### 7. Sistema de Filtros de Contenido
- [ ] **AÃ±adir ajuste de filtro**: Implementar la configuraciÃ³n `contentFilterLevel` (Ninguno, EstÃ¡ndar, Estricto) sugerida.
- [ ] **LÃ³gica de filtrado**: Crear una funciÃ³n `ContentFilter` que procese el texto antes de enviarlo a la API para reemplazar palabras o frases no deseadas.

### 8. MÃ©tricas y Analytics (Opcional)
- [ ] **Mecanismo de opt-in**: AÃ±adir una opciÃ³n de configuraciÃ³n para que los GMs puedan habilitar el envÃ­o anÃ³nimo de mÃ©tricas de uso.
- [ ] **RecopilaciÃ³n de datos bÃ¡sicos**: Registrar eventos como `generacion_exitosa`, `error_api`, `cache_hit` para ayudar a identificar problemas y priorizar mejoras.
```

---

## `templates/actor-voice-setting.txt`

```html
<div class="form-group gemini-tts-actor-voice">
    <label for="gemini-tts-voice-select">{{localize "GEMINI-TTS.ActorVoiceLabel"}}</label>
    <select name="flags.{{moduleId}}.voice" id="gemini-tts-voice-select">
        {{#each voices}}
        <option value="{{this.key}}" {{#if this.selected}}selected{{/if}}>{{this.label}}</option>
        {{/each}}
    </select>
</div>
```

---

## `templates/tts-panel.txt`

```html
<div class="form-group">
    <label for="tts-text">{{localize "GEMINI-TTS.TextPlaceholder"}}</label>
    <textarea name="tts-text" id="tts-text" rows="4" placeholder="{{localize 'GEMINI-TTS.TextPlaceholder'}}"></textarea>
</div>

<div class="form-group">
    <label for="tts-voice">{{localize "GEMINI-TTS.VoiceLabel"}}</label>
    <select name="tts-voice" id="tts-voice">
        {{#each voices}}
        <option value="{{this.key}}" {{#if this.selected}}selected{{/if}}>{{this.label}}</option>
        {{/each}}
    </select>
</div>

<div class="form-group">
    <label for="tts-volume-slider">{{localize "GEMINI-TTS.VolumeLabel"}} <span id="tts-volume-value">{{volume}}%</span></label>
    <input type="range" id="tts-volume-slider" min="0" max="100" value="{{volume}}" class="slider">
</div>

<div class="panel-controls">
    <button class="tts-speak-btn"><i class="fas fa-microphone-alt"></i> {{localize "GEMINI-TTS.SpeakButton"}}</button>
    <button class="tts-stop-all-btn" style="background-color: #c9302c;"><i class="fas fa-stop-circle"></i> {{localize "GEMINI-TTS.StopAllButton"}}</button>
</div>

<div class="tts-queue">
    <h4><i class="fas fa-list-ol"></i> {{localize "GEMINI-TTS.QueueTitle"}}</h4>
    <ol class="tts-queue-list">
        {{#if queue.length}}
            {{#each queue}}
            <li title="{{this.text}}">{{this.text}}</li>
            {{/each}}
        {{else}}
            <li>&nbsp;</li>
        {{/if}}
    </ol>
</div>